/*
 * test_vector_add.c - E2E test: nvcc-compiled vector add kernel
 *
 * Uses the CUDA driver API to load PTX generated by nvcc, allocate buffers,
 * launch the kernel, and verify correctness on our Vulkan backend.
 */
#include "e2e_common.h"

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <vector_add.ptx>\n", argv[0]);
        return 1;
    }

    const int N = 1024;
    const int blockSize = 256;
    const int gridSize = (N + blockSize - 1) / blockSize;

    /* Init */
    CHECK_CU(cuInit(0));
    CUdevice dev;
    CHECK_CU(cuDeviceGet(&dev, 0));
    CUcontext ctx;
    CHECK_CU(cuCtxCreate(&ctx, NULL, 0, dev));

    /* Load PTX module */
    char *ptx = read_ptx_file(argv[1]);
    CUmodule mod;
    CHECK_CU(cuModuleLoadData(&mod, ptx));
    CUfunction func;
    CHECK_CU(cuModuleGetFunction(&func, mod, "vecAdd"));
    free(ptx);

    /* Allocate device memory */
    size_t bytes = N * sizeof(float);
    CUdeviceptr d_a, d_b, d_c;
    CHECK_CU(cuMemAlloc(&d_a, bytes));
    CHECK_CU(cuMemAlloc(&d_b, bytes));
    CHECK_CU(cuMemAlloc(&d_c, bytes));

    /* Prepare host data */
    float *h_a = (float *)malloc(bytes);
    float *h_b = (float *)malloc(bytes);
    float *h_c = (float *)malloc(bytes);
    for (int i = 0; i < N; i++) {
        h_a[i] = (float)i;
        h_b[i] = (float)(i * 2);
    }

    /* Copy to device */
    CHECK_CU(cuMemcpyHtoD(d_a, h_a, bytes));
    CHECK_CU(cuMemcpyHtoD(d_b, h_b, bytes));

    /* Launch kernel */
    int n = N;
    void *params[] = { &d_a, &d_b, &d_c, &n };
    CHECK_CU(cuLaunchKernel(func,
        gridSize, 1, 1,
        blockSize, 1, 1,
        0, NULL, params, NULL));
    CHECK_CU(cuCtxSynchronize());

    /* Copy results back */
    CHECK_CU(cuMemcpyDtoH(h_c, d_c, bytes));

    /* Verify */
    int errors = 0;
    for (int i = 0; i < N; i++) {
        float expected = h_a[i] + h_b[i];
        if (!check_float_eq(h_c[i], expected, 1e-5f)) {
            if (errors < 10)
                fprintf(stderr, "MISMATCH at %d: got %f, expected %f\n",
                        i, h_c[i], expected);
            errors++;
        }
    }

    /* Cleanup */
    cuMemFree(d_a);
    cuMemFree(d_b);
    cuMemFree(d_c);
    cuModuleUnload(mod);
    cuCtxDestroy(ctx);
    free(h_a);
    free(h_b);
    free(h_c);

    if (errors == 0) {
        printf("PASS: vector_add (%d elements)\n", N);
        return 0;
    } else {
        fprintf(stderr, "FAIL: %d/%d mismatches\n", errors, N);
        return 1;
    }
}
